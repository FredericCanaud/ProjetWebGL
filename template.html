<!DOCTYPE html>

<html lang="en">

<head>
	<title>WebGL 2020 - L3 - FST - UNILIM</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<!-- <script type="text/javascript" src="http://ff.kis.v2.scr.kaspersky-labs.com/FD126C42-EBFA-4E12-B309-BB3FDD723AC1/main.js?attr=JagMHoP5s5rM8MDRnmB7BaPFViGHpw_EUTtHQUW8TIlqPYQneP84Ew-wuwEAmk0I9K9Zce7q3oH7Zt4KNc56y6-YJ2QyL1xsuU5H7Vjlj-FOzxRsiTT8MYRbTtuKBrwVk6xQcTNaxQE7guHy_0zkxsEW6L7RXLdPX83llPHeKgc" charset="UTF-8"></script><link rel="stylesheet" crossorigin="anonymous" href="http://ff.kis.v2.scr.kaspersky-labs.com/E3E8934C-235A-4B0E-825A-35A08381A191/abn/main.css?attr=aHR0cDovL3d3dy51bmlsaW0uZnIvcGFnZXNfcGVyc28vZ3VpbGxhdW1lLmdpbGV0L0Vuc2VpZ25lbWVudC9JbmZvR3JhcGhpcXVlL1dlYkdML1RQL3RlbXBsYXRlLmh0bWw"/></head>
-->

<body>
	<script src="three.js"></script>
	<script src="threeCSG.js"></script>
	<script src="dat.gui.min.js"></script>

	<script id="fonctions">
		// écrire fonction ici
	</script>



<!--
//////////////////////////////////////////////////////
///////////////////  SHADER PART  ////////////////////
//////////////////////////////////////////////////////
-->


	<script type="x-shader/x-vertex" id="vertexShader">
		uniform float delta; // peut-être
		uniform float multiplicateur; //hauteur du déplacement
		uniform float time; // le temps
		uniform float scale; // si l'objet a été upscale
		varying vec3 vUv; // = position
		varying vec2 bande; //la bande

		// renvoie le rapport entre la distance entre le x du point moins le min(ou max) et la distance entre le min(ou le max) de la bande et le centre de la bande
		float distanceCentreX(vec2 bande, float centreBande, vec3 vertex){
			float distanceAuCentre;
			if (vertex.x<centreBande){
				distanceAuCentre = abs(bande.x-vertex.x) / abs(bande.x-centreBande);
			}else{
				distanceAuCentre = abs(bande.y-vertex.x) / abs(bande.y-centreBande);
			}
			return distanceAuCentre;
		}

		float distanceCentreY(vec2 bande, float centreBande, vec3 vertex){
			float distanceAuCentre;
			if (vertex.y<centreBande){
				distanceAuCentre = abs(bande.x-vertex.y) / abs(bande.x-centreBande);
			}else{
				distanceAuCentre = abs(bande.y-vertex.y) / abs(bande.y-centreBande);
			}
			return distanceAuCentre;
		}

		float distanceCentreZ(vec2 bande, float centreBande, vec3 vertex){
			float distanceAuCentre;
			if (vertex.z<centreBande){
				distanceAuCentre = abs(bande.x-vertex.z) / abs(bande.x-centreBande);
			}else{
				distanceAuCentre = abs(bande.y-vertex.z) / abs(bande.y-centreBande);
			}
			return distanceAuCentre;
		}
		///////////////////////////////////////////////
		///////////////////////////////////////////////

		void main(){
			vUv = position;

			vec3 p = position;

			float amplitude = 7.0; // amplitude de la bande
			float min = (-10.0 * amplitude * sin(time/1900.0)) / scale; // minimum de la bande  ->////////
			float max = min + (10.0/ scale) ; // maximum de la bande ////////<-
			bande = vec2(min, max);

			float centreBande = (max+min)/2.0;

			//vague sur l'axe x
			if ((vUv.x > bande.x)&&(vUv.x < bande.y)){
				p = p + normal * multiplicateur * (distanceCentreX(bande, centreBande, p)/100.0);
			}

			//vague sur l'axe y
			if ((vUv.y > bande.x)&&(vUv.y < bande.y)){
				p = p + normal * multiplicateur * (distanceCentreY(bande, centreBande, p)/100.0);
			}

			// bande bleu sur l'axe z
			if ((vUv.z > bande.x)&&(vUv.z < bande.y)){
				p = p + normal * multiplicateur * (distanceCentreZ(bande, centreBande, p)/100.0);
			}

			vec4 modelViewPosition = modelViewMatrix * vec4(p, 1.0);
			gl_Position = projectionMatrix * modelViewPosition;
		}
	</script>


	<script type="x-shader/x-fragment" id="fragmentShader">
		uniform float delta; // éventuellement
		uniform float time; // le temps
		uniform vec3 color; // la couleur
		uniform float scale; //si l'objet a été scale
		varying vec3 vUv; // position du pixel dans l'espace
		varying vec2 bande; // la bande

		void main(){
			float r = color.r;
			float g = color.g;
			float b = color.b;

			// bande rouge sur l'axe x
			if ((vUv.x > bande.x)&&(vUv.x < bande.y)){
				r = 1.0;
			}

			// bande verte sur l'axe y
			if ((vUv.y > bande.x)&&(vUv.y < bande.y)){
				g = 1.0;
			}

			// bande bleu sur l'axe z
			if ((vUv.z > bande.x)&&(vUv.z < bande.y)){
				b = 1.0;
			}

			vec3 rgb = vec3(r, g, b);
			gl_FragColor = vec4(rgb, 1.0);
		}
	</script>

<!--
	///////////////////////////////////////////////
	////// Avec texture sur le lapin
	///////////////////////////////////////////////
-->
	<script type="x-shader/x-vertex" id="vertexShader2">
		uniform float multiplicateur; //hauteur du déplacement
		uniform float time; // le temps
		uniform float scale; // si l'objet a été upscale
		varying vec3 vUv; // = position
		varying vec2 bande; //la bande
		varying vec2 textureVec; // coordonnées de texture à un point donné

		///////////////////////////////////////////////
		///////////////////////////////////////////////

		void main(){
			vUv = position;
			textureVec = uv;
			vec3 p = position;

			// gonflement du lapin
			p = p + normal * 0.003 * abs(sin(time/1000.0)*0.5);

			vec4 modelViewPosition = modelViewMatrix * vec4(p, 1.0);
			gl_Position = projectionMatrix * modelViewPosition;
		}
	</script>

	<script type="x-shader/x-fragment" id="fragmentShader2">
		uniform float time; // le temps
		uniform vec3 color; // la couleur (si on veut)
		uniform float scale; // si l'objet est scale
		varying vec3 vUv; // position du pixel dans l'espace
		uniform sampler2D texture1; // texture de l'objet
		varying vec2 textureVec; // coordonnées de texture à un point donné

		void main(){
			// chargement de la texture
			vec4 text = texture2D(texture1,textureVec);

			// application de la texture
			gl_FragColor = text;
		}
	</script>


<!--
	///////////////////////////////////
	/// SHADER SPHERE DE DYSON
	//////////////////////////////////
-->

	<script type="x-shader/x-vertex" id="vertexShaderDyson">
		uniform float time; // le temps
		varying vec3 vUv; // = position

		float rand(vec2 co){
			return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
		}

		///////////////////////////////////////////////
		///////////////////////////////////////////////

		void main(){
			vUv = position;

			vec3 p = position;

			if (rand(p.xy * time/500.0) < 0.0000001){
				p = p + normal * 1.2;
			}

			vec4 modelViewPosition = modelViewMatrix * vec4(p, 1.0);
			gl_Position = projectionMatrix * modelViewPosition;
		}
	</script>

	<script type="x-shader/x-fragment" id="fragmentShaderDyson">
		uniform float time; // le temps
		uniform vec3 color; // la couleur
		varying vec3 vUv; // position du pixel dans l'espace

		float rand(vec2 co){
			return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
		}

		void main(){
			float r = color.r;
			float g = color.g;
			float b = color.b;

			float random = rand(vUv.xy * sin(time/800.0));

			if (random < 0.1){
				r = 0.03;
				g = 0.7;
				b = 1.0;
			}

			vec3 rgb = vec3(r, g, b);
			gl_FragColor = vec4(rgb, 1.0);
		}
	</script>


<!--
//////////////////////////////////////////////////////
//////////////// SHADER PART OVER ////////////////////
//////////////////////////////////////////////////////
-->


	<script type="module">
		//import * as THREE from 'https://unpkg.com/three@0.121.1/build/three.module.js';
		import { OrbitControls } from 'https://unpkg.com/three@0.121.1/examples/jsm/controls/OrbitControls.js';
		import { OBJLoader } from 'https://unpkg.com/three@0.121.1/examples/jsm/loaders/OBJLoader.js';


		// constant
		const width = window.innerWidth;
		const height = window.innerHeight;


		// global object
		let renderer, scene, camera, controls, axesHelper, bgTexture, bgWidth, bgHeight;

		//shaderMaterial
		let materialS;
		let vertexDisplacement;

		//tailleEffet
		var tailleEffetDepartSoleil = 1;

		//compteur vitesse selfRotation
		let vitesseSelfRotationPlanete1 = 0;

		//compteur vitesse rotation
		let vitesseRotationPlanete1Sun = 0;

		//gui
		var lumiereControl;

		//planete
		let sun;

		// object
		let sphere;

		// light
		let pointLight;
		let pointLightPurple;
		let dysonLight;
		let sceneLight;


		// events
		window.addEventListener('keydown', onKeyDown, false);
		window.addEventListener('resize', onWindowResize, false);


		// renderer
		renderer = new THREE.WebGLRenderer({ antialias: true });
		renderer.setPixelRatio(window.devicePixelRatio);
		renderer.setSize(width, height);
		document.body.appendChild(renderer.domElement);
		renderer.setClearColor(0x090909, 1.0);//0x00ffff
		renderer.clear();

		// camera
		camera = new THREE.PerspectiveCamera(50, width/height, 1, 10000); // PerspectiveCamera(fov, aspect, near, far );
		camera.position.set(10, -100, 800);
		camera.rotation.set(0,0,0);
		camera.up = new THREE.Vector3( 0 ,1, 0 );
		camera.lookAt(new THREE.Vector3( 0 ,0, 0 ));

		// orbit controller
		controls = new OrbitControls(camera, renderer.domElement);

		// scene
		scene = new THREE.Scene();

		axesHelper = new THREE.AxesHelper(50);
		//scene.add(axesHelper);

		// lights
		pointLight = new THREE.PointLight(0xfeefaf, 10, 500);
		pointLight.position.set(0, 0, 0);
		scene.add(pointLight);

		sceneLight = new THREE.AmbientLight(0xffffff, 0);
		sceneLight.position.set(10,-100,800);
		scene.add(sceneLight);


		// http://www.unilim.fr/pages_perso/guillaume.gilet/Enseignement/InfoGraphique/WebGL/PipelineWebGL_2020.html#/9/2
		// http://www.unilim.fr/pages_perso/guillaume.gilet/Enseignement/InfoGraphique/WebGL/TP/TP3.html#/3
		// http://tpwebgl/tp3/template.html

		var uniformsLapin = {
			delta:{value: 0},
			time:{value: 0},
			scale:{
				type:'f',
				value:600
			},
			color:{
				type:'c',
				value: new THREE.Color(0.3, 0.3, 0.3)
			},
			multiplicateur: {
				type:'f',
				value: 1.3
			}
		}

		var uniformsCube = {
			delta:{value: 0},
			time:{value: 0},
			scale:{
				type:'f',
				value:1
			},
			color:{
				type:'c',
				value: new THREE.Color(0.3, 0.3, 0.3)
			},
			multiplicateur: {
				type:'f',
				value: 600.0
			}
		}

		var uniformsLapinTexture = {
			time:{value: 0},
			scale:{
				type:'f',
				value:600
			},
			texture1: {
				type: "t",
				value: new THREE.TextureLoader().load( "./soleil.jpg" )
			},
			color:{
				type:'c',
				value: new THREE.Color(0.3, 0.3, 0.3)
			},
			multiplicateur: {
				type:'f',
				value: 1.3
			}
		}


		///////////////////////////
		///////////////////////////


		materialS = new THREE.ShaderMaterial({
			uniforms: uniformsLapin,
			vertexShader: document.getElementById('vertexShader').textContent,
			fragmentShader: document.getElementById('fragmentShader').textContent
		});

		let loader = new OBJLoader();


		///////////////////////////
		///////////////////////////

		let materialD = new THREE.ShaderMaterial({
			uniforms: uniformsLapinTexture,
			vertexShader: document.getElementById('vertexShader2').textContent,
			fragmentShader: document.getElementById('fragmentShader2').textContent
		});

		///////////////////////////
		///////////////////////////

		let materialC = new THREE.ShaderMaterial({
			uniforms: uniformsCube,
			vertexShader: document.getElementById('vertexShader').textContent,
			fragmentShader: document.getElementById('fragmentShader').textContent
		});

		// sun
		var geometry = new THREE.SphereGeometry(80,32,32);
		var materialSun = new THREE.MeshPhongMaterial();
		materialSun.map=THREE.ImageUtils.loadTexture('soleil.jpg');
		sun = new THREE.Mesh(geometry, materialSun);

		scene.add(sun);

		//planete1

		var geometry = new THREE.SphereGeometry(20,32,32);
		var materialPlanete1 = new THREE.MeshPhongMaterial();
		materialPlanete1.map=THREE.ImageUtils.loadTexture('makemake.jpg');
		var planete1 = new THREE.Mesh(geometry,materialPlanete1);
		planete1.position.set(800,0,0);

		scene.add(planete1);


		//effetSoleil

		var effetSoleilMaterial = new THREE.MeshStandardMaterial({ emissive: 0xfff266, emissiveIntensity: 1 });
    var effetSoleilGeometry = new THREE.SphereGeometry(80, 24, 24);
    var effetSoleil = new THREE.Mesh(effetSoleilGeometry, effetSoleilMaterial);

    loader.load("sphere.obj", function(effetSoleil){

        effetSoleil.traverse( function( child ) {
            if ( child.isMesh ) {
                child.geometry.computeVertexNormals();
                child.material = materialD;
								child.position.set(-200,0,0);
            }
        });
        effetSoleil.scale.set(600,600,600);
        effetSoleil.position.x = 400;
        effetSoleil.needsUpdate = true;

        scene.add(effetSoleil);
    });



		scene.add(effetSoleil);



		//planete2

		var geometry = new THREE.SphereGeometry(100,32,32);
		var materialPlanete2 = new THREE.MeshPhongMaterial();
		materialPlanete2.map=THREE.ImageUtils.loadTexture('mars.jpg');
		var planete2 = new THREE.Mesh(geometry,materialPlanete2);
		planete2.position.set(-200,0,0);

		scene.add(planete2);


		//deathStar

		loader.load( "ds.obj", function (objet){
			let material = new THREE.ShaderMaterial( {}  );

			objet.material = material;
			objet.traverse( function( child ) {
				var texture = new THREE.TextureLoader().load( "ds.jpg"  );

				if ( child.isMesh ) child.geometry.computeVertexNormals();
				child.material.map=texture;

			} );



			objet.position.set(0,300,0);
			objet.rotateX(500);
			objet.rotateZ(600);

			objet.scale.set(2,2,2);
			scene.add(objet);
		});

		//=====================================================================================================

		//////////////////////////////////
		/// GROUPE DE LA SPHERE DE DYSON
		//////////////////////////////////

		// groupe qui contient la sphere
		const groupeDyson = new THREE.Group();
		groupeDyson.position.x = 1400;

		// uniform pour le shader de l'étoile
		let uniformDyson={
			time:{
				value: 0.0
			},
			color:{
				type:'c',
				value: new THREE.Color(0.03, 0.87, 1.0)
			}
		}

		// shader de l'étoile
		let materialDyson = new THREE.ShaderMaterial({
			uniforms: uniformDyson,
			vertexShader: document.getElementById('vertexShaderDyson').textContent,
			fragmentShader: document.getElementById('fragmentShaderDyson').textContent
		});

		// création de l'étoile
		let sphereDyson = new THREE.SphereBufferGeometry(40, 64, 64);
		sphereDyson.computeVertexNormals();
		let dysonStar = new THREE.Mesh(sphereDyson, materialDyson);

		// lumière pour la sphère de Dyson
		dysonLight = new THREE.PointLight(0x09deff, 1, 300);
		dysonStar.add(dysonLight);

		// ajout de l'étoile au groupe
		groupeDyson.add(dysonStar);

		// paramètre pour créer un anneau
		let geometryRing1 = new THREE.CylinderBufferGeometry(60, 60, 10, 64, 10, true);
		let geometryRing2 = new THREE.CylinderBufferGeometry(70, 70, 10, 64, 10, true);
		let geometryRing3 = new THREE.CylinderBufferGeometry(80, 80, 10, 64, 10, true);
		let materialRing = new THREE.MeshLambertMaterial({color: 0xffffff, side: THREE.DoubleSide});

		// création des anneaux
		let anneau1 = new THREE.Mesh(geometryRing1, materialRing);
		let anneau2 = new THREE.Mesh(geometryRing2, materialRing);
		let anneau3 = new THREE.Mesh(geometryRing3, materialRing);

		// ajout des anneaux au groupe
		groupeDyson.add(anneau1);
		groupeDyson.add(anneau2);
		groupeDyson.add(anneau3);


		// ajout du groupe à la scène
		scene.add(groupeDyson);

		////////////////////////////////////
		// FIN GROUPE DE LA SPHERE DE DYSON
		////////////////////////////////////

		//=========================================================================================================

		////////////////////////////////////
		/// GUI
		////////////////////////////////////

		// options of the gui
		let options = {
			camera :{
				lookAtTheDysonSphere : function(){
					camera.position.x = groupeDyson.position.x;
					camera.position.y = 100;
					camera.position.z = 400;
					camera.rotation.set(groupeDyson.position.x,0,0);
					camera.lookAt(groupeDyson.position);
					controls.target = groupeDyson.position;
				}
			}
		}

		lumiereControl= new function() {

			// donner l'intensité de la lumière rouge de base
			this.intensiteSoleil = 2;
			this.intensiteLumiereGeneral=1;
		}

		// création du GUI
		let gui = new dat.GUI();

		//ajoute une rubrique lumiere
		let lumiere = gui.addFolder('lumiere');

		//ajouter un controle de l'intensité de la lumière du soleil dans le gui
		lumiere.add(lumiereControl,'intensiteSoleil',0,20).listen();

		//ajouter un controle de l'intensité de la lumière général dans le gui
		lumiere.add(lumiereControl,'intensiteLumiereGeneral',0,2).listen();

		//avoir la rubrique ouverte par défaut
		lumiere.open();

		// option pour la camera
		let optCam = gui.addFolder('Camera');
		optCam.add(options.camera, 'lookAtTheDysonSphere').name("DysonSphere").listen();
		optCam.open();


		//=================================================


		//effetDebut
		const geometryEffetDebutt = new THREE.RingGeometry( 28, 30, 32 );
		const materialEffetDebutt = new THREE.MeshBasicMaterial( {color: 0xffffff} );
		const effetDebutt = new THREE.Mesh( geometryEffetDebutt, materialEffetDebutt );
		effetDebutt.rotateX(-51);
		scene.add( effetDebutt );


		//anneau
		const geometryAnneau = new THREE.RingGeometry( 28, 30, 32 );
		const materialAnneau = new THREE.MeshBasicMaterial( { color: 0xffffff, side: THREE.DoubleSide } );
		materialAnneau.map=THREE.ImageUtils.loadTexture('saturnring.png');
		const anneau = new THREE.Mesh( geometryAnneau, materialAnneau );
		anneau.rotateX(360);
		scene.add( anneau );

		// ajouter background https://discourse.threejs.org/t/background-image-texture-is-not-working/15435

		const loader2 = new THREE.TextureLoader();
		scene.background = loader2.load( 'stars_milkyway.jpg' );
		animate();

	/////////////////////////////////////////////////
	/////////////////////////////////////////////////
	/////////////////////////////////////////////////


		function render() {
			renderer.render(scene, camera);

			//fait tourner le dodecahedron autour du centre du groupe horizontalement avec un diametre de 250
			planete1.position.x = sun.position.x + Math.cos(vitesseRotationPlanete1Sun/500)* 800;
			planete1.position.z = sun.position.z + Math.sin(vitesseRotationPlanete1Sun/500)* 800;
			planete1.position.y = sun.position.y;

			planete2.position.x = sun.position.x - Math.cos(vitesseRotationPlanete1Sun/500)* 450;
			planete2.position.z = sun.position.z - Math.sin(vitesseRotationPlanete1Sun/500)* 450;
			planete2.position.y = sun.position.y;

			anneau.position.x = planete1.position.x;
			anneau.position.y = planete1.position.y;
			anneau.position.z = planete1.position.z;

			//lumiere du soleil
			pointLight.intensity=lumiereControl.intensiteSoleil;

			//lumiere de la scene
			sceneLight.intensity=lumiereControl.intensiteLumiereGeneral*0.5;


			effetDebutt.scale.set(tailleEffetDepartSoleil,tailleEffetDepartSoleil,tailleEffetDepartSoleil) ;
		}

		function animate(t) {
			planete1.rotation.set(1,vitesseSelfRotationPlanete1/800,1);
			vitesseSelfRotationPlanete1=vitesseSelfRotationPlanete1+10*1;

			vitesseRotationPlanete1Sun = vitesseRotationPlanete1Sun+10;

			tailleEffetDepartSoleil = tailleEffetDepartSoleil*1.02;

			/////////////////////////////
			/// GROUPE SPHERE DE DYSON
			/////////////////////////////

			// rotation des anneaux
			anneau1.rotation.set(0, t/800, t/800);
			anneau2.rotation.set(t/1000, t/1000, 0);
			anneau3.rotation.set(t/1200, 0, t/1200);

			// envoie du temps dans le shader de la sphere
			uniformDyson.time.value = t;


			///////////////////////////////////////////
			///////////////////////////////////////////

			// envoie du temps dans le shader
			uniformsLapin.time.value = t;
			uniformsLapinTexture.time.value = t;
			uniformsCube.time.value = t;

			// RENDER
			render();
			requestAnimationFrame(animate);
			controls.update();
		}



	/////////////////////////////////////////////////
	/////////////////////////////////////////////////
	/////////////////////////////////////////////////


		function onWindowResize() {
			camera.aspect = width /height;
			camera.updateProjectionMatrix();

			renderer.setSize(width, height);
		}


		function onKeyDown(event) {
			switch (event.key) {
				case '1':
				print("Touche 1 !");
				break;
			}
		}

		function print(message) {
			console.log(message);
		}


	</script>
</body>

</html>
